namespace Signal.CANdy.Core

open System
open System.IO
open Signal.CANdy.Core.Ir
open Signal.CANdy.Core.Errors

module Codegen =

    module Utils =
        // Build a macro-safe header guard from prefix + base name
        let private guard (prefix: string) (baseName: string) =
            let raw = (prefix + baseName).ToUpperInvariant()
            raw
            |> Seq.map (fun ch -> if Char.IsLetterOrDigit ch then ch else '_')
            |> Seq.toArray
            |> fun arr -> new string(arr)

        let utilsHeaderName (config: Signal.CANdy.Core.Config.Config) = sprintf "%sutils.h" config.FilePrefix
        let utilsSourceName (config: Signal.CANdy.Core.Config.Config) = sprintf "%sutils.c" config.FilePrefix

        let utilsHContent (config: Signal.CANdy.Core.Config.Config) =
            let banner = sprintf "/* Generated by Signal CANdy\n   file_prefix=%s, phys_type=%s, phys_mode=%s, dispatch=%s, motorola_start_bit=%s */\n" config.FilePrefix config.PhysType config.PhysMode config.Dispatch config.MotorolaStartBit
            let g = guard config.FilePrefix "utils_h"
            banner + (sprintf "#ifndef %s\n#define %s\n\n#include <stdint.h>\n#include <stdbool.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Little-endian bit extraction functions\nuint64_t get_bits_le(const uint8_t* data, uint16_t start_bit, uint16_t length);\n\n// Little-endian bit insertion functions\nvoid set_bits_le(uint8_t* data, uint16_t start_bit, uint16_t length, uint64_t value);\n\n// Big-endian (Motorola) bit extraction\nuint64_t get_bits_be(const uint8_t* data, uint16_t start_bit, uint16_t length);\n\n// Big-endian (Motorola) bit insertion\nvoid set_bits_be(uint8_t* data, uint16_t start_bit, uint16_t length, uint64_t value);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // %s" g g g)

        let utilsCContent (config: Signal.CANdy.Core.Config.Config) =
            let uH = utilsHeaderName config
            let banner = sprintf "/* Generated by Signal CANdy\n   file_prefix=%s, phys_type=%s, phys_mode=%s, dispatch=%s, motorola_start_bit=%s */\n" config.FilePrefix config.PhysType config.PhysMode config.Dispatch config.MotorolaStartBit
            banner + "#include \"" + uH + "\"\n\n// Little-endian bit extraction\nuint64_t get_bits_le(const uint8_t* data, uint16_t start_bit, uint16_t length) {\n    uint64_t value = 0;\n    uint16_t byte_offset = start_bit / 8;\n    uint16_t bit_offset = start_bit % 8;\n    for (uint16_t i = 0; i < 8 && (byte_offset + i) < 8; ++i) {\n        value |= (uint64_t)data[byte_offset + i] << (i * 8);\n    }\n    value >>= bit_offset;\n    value &= (1ULL << length) - 1;\n    return value;\n}\n\n// Little-endian bit insertion\nvoid set_bits_le(uint8_t* data, uint16_t start_bit, uint16_t length, uint64_t value) {\n    uint16_t byte_offset = start_bit / 8;\n    uint16_t bit_offset = start_bit % 8;\n    uint64_t clear_mask = ((1ULL << length) - 1) << bit_offset;\n    for (uint16_t i = 0; i < 8 && (byte_offset + i) < 8; ++i) {\n        data[byte_offset + i] &= ~(uint8_t)(clear_mask >> (i * 8));\n    }\n    uint64_t insert_value = (value & ((1ULL << length) - 1)) << bit_offset;\n    for (uint16_t i = 0; i < 8 && (byte_offset + i) < 8; ++i) {\n        data[byte_offset + i] |= (uint8_t)(insert_value >> (i * 8));\n    }\n}\n\n// Big-endian (Motorola) bit extraction (DBC semantics, sawtooth)\nuint64_t get_bits_be(const uint8_t* data, uint16_t start_bit, uint16_t length) {\n    uint64_t value = 0;\n    int byte = start_bit / 8;\n    int bit = start_bit % 8; // 7..0 within byte, 7 is MSB\n    for (uint16_t i = 0; i < length; ++i) {\n        int curByte = byte;\n        int curBit = bit - (int)i;\n        while (curBit < 0) { curBit += 8; ++curByte; } // move to next higher byte\n        uint8_t b = data[curByte];\n        uint8_t bitval = (uint8_t)((b >> curBit) & 1u);\n        value = (value << 1) | bitval; // assemble MSB-first\n    }\n    return value;\n}\n\n// Big-endian (Motorola) bit insertion (DBC semantics, sawtooth)\nvoid set_bits_be(uint8_t* data, uint16_t start_bit, uint16_t length, uint64_t value) {\n    int byte = start_bit / 8;\n    int bit = start_bit % 8;\n    for (uint16_t i = 0; i < length; ++i) {\n        int curByte = byte;\n        int curBit = bit - (int)i;\n        while (curBit < 0) { curBit += 8; ++curByte; } // move to next higher byte\n        uint8_t bitval = (uint8_t)((value >> (length - 1 - i)) & 1u); // MSB-first\n        data[curByte] = (uint8_t)((data[curByte] & (uint8_t)~(1u << curBit)) | (uint8_t)(bitval << curBit));\n    }\n}"

        // Helper to choose C accessor based on byte order
        let accessorNames (byteOrder: ByteOrder) =
            match byteOrder with
            | ByteOrder.Little -> ("get_bits_le", "set_bits_le")
            | ByteOrder.Big -> ("get_bits_be", "set_bits_be")

        // Convert Motorola (BE) start bit from LSB-convention to MSB-convention using sawtooth numbering.
        let internal motorolaMsbFromLsb (start: int) (length: int) : int =
            let steps = max 0 (length - 1)
            let mutable byteIdx = start / 8
            let mutable bitIdx = start % 8 // 0..7, where 7 is MSB
            for _ in 1 .. steps do
                if bitIdx < 7 then bitIdx <- bitIdx + 1
                else (byteIdx <- byteIdx + 1; bitIdx <- 7)
            byteIdx * 8 + bitIdx

        // Choose effective start bit depending on config for Motorola signals; LE stays unchanged.
        let chooseStartBit (signal: Signal) (config: Signal.CANdy.Core.Config.Config) : int =
            let start = int signal.StartBit
            let len = int signal.Length
            match signal.ByteOrder with
            | ByteOrder.Big ->
                match config.MotorolaStartBit.ToLowerInvariant() with
                | "lsb" -> motorolaMsbFromLsb start len
                | _ -> start // default "msb"
            | _ -> start

        // Detect if factor equals 10^-n within tolerance and return integer scale (10^n)
        let tryPowerOfTenScale (factor: float) : int64 option =
            if factor <= 0.0 then None else
            let eps = 1e-12
            let rec loop n =
                if n > 9 then None
                else
                    let scaleF = pown 10.0 n
                    if abs (factor - (1.0 / scaleF)) < eps then Some (int64 (pown 10 n)) else loop (n + 1)
            loop 0

    module Message =
        open Utils

        // Sanitize a string to an uppercase C identifier (A-Z0-9_), prefix with N_ if starting with a digit or empty
        let private sanitizeEnumIdent (s: string) : string =
            let up = s.ToUpperInvariant()
            let mapped =
                up
                |> Seq.map (fun ch -> if Char.IsLetterOrDigit ch then ch else '_')
                |> Seq.toArray
                |> fun arr -> new string(arr)
            let trimmed =
                mapped.Trim([|'_'|])
                |> fun t -> if String.IsNullOrWhiteSpace t then "N" else t
            let start = trimmed.[0]
            if Char.IsDigit start then "N_" + trimmed else trimmed

        let private fieldDecl (s: Signal) = sprintf "    float %s;" s.Name

        let private genDecodeForSignal (s: Signal) (doRangeCheck: bool) (config: Signal.CANdy.Core.Config.Config) =
            let len = int s.Length
            let startEff = chooseStartBit s config
            let (getFn, _) = accessorNames s.ByteOrder
            let raw = sprintf "raw_%s" s.Name
            let signFix = if s.IsSigned then sprintf "    if (%s & (1ULL << (%d - 1))) { %s |= ~((1ULL << %d) - 1); }" raw len raw len else ""
            let physAssignFloatDouble = sprintf "    msg->%s = (float)((double)%s * %.17g + %.17g);" s.Name raw s.Factor s.Offset
            let physAssignFloatFloat = sprintf "    msg->%s = (float)(((float)%s * (float)%.17g) + (float)%.17g);" s.Name raw s.Factor s.Offset
            let physAssign =
                match config.PhysType.ToLowerInvariant() with
                | "fixed" ->
                    match Utils.tryPowerOfTenScale s.Factor with
                    | Some scale when abs (s.Offset - Math.Round(s.Offset)) < 1e-12 ->
                        sprintf "    msg->%s = (float)(((double)%s + (%.0f)) / (double)%d);" s.Name raw (Math.Round(s.Offset * (float scale))) scale
                    | _ -> (match config.PhysMode.ToLowerInvariant() with | "fixed_float" -> physAssignFloatFloat | _ -> physAssignFloatDouble)
                | _ -> (match config.PhysMode.ToLowerInvariant() with | "float" -> physAssignFloatFloat | _ -> physAssignFloatDouble)
            let rangeCheck =
                if doRangeCheck then
                    match s.Minimum, s.Maximum with
                    | Some minV, Some maxV -> Some (sprintf "    if (msg->%s < %.17g || msg->%s > %.17g) { return false; }" s.Name minV s.Name maxV)
                    | Some minV, None -> Some (sprintf "    if (msg->%s < %.17g) { return false; }" s.Name minV)
                    | None, Some maxV -> Some (sprintf "    if (msg->%s > %.17g) { return false; }" s.Name maxV)
                    | _ -> None
                else None
            [ sprintf "    uint64_t %s = 0;" raw
              sprintf "    // %s: start=%d len=%d factor=%.17g offset=%.17g" s.Name startEff len s.Factor s.Offset
              sprintf "    %s = %s(data, %d, %d);" raw getFn startEff len
              if signFix <> "" then signFix else null
              physAssign
              match rangeCheck with | Some r -> r | None -> null ]
            |> List.choose (fun x -> if isNull (box x) then None else Some x)
            |> String.concat "\n"

        let private genEncodeForSignal (s: Signal) (doRangeCheck: bool) (config: Signal.CANdy.Core.Config.Config) =
            let len = int s.Length
            let startEff = chooseStartBit s config
            let (_, setFn) = accessorNames s.ByteOrder
            let rangeChecks =
                if doRangeCheck then
                    match s.Minimum, s.Maximum with
                    | Some minV, Some maxV -> Some (sprintf "    if (msg->%s < %.17g || msg->%s > %.17g) { return false; }" s.Name minV s.Name maxV)
                    | Some minV, None -> Some (sprintf "    if (msg->%s < %.17g) { return false; }" s.Name minV)
                    | None, Some maxV -> Some (sprintf "    if (msg->%s > %.17g) { return false; }" s.Name maxV)
                    | _ -> None
                else None
            let computeRawDouble =
                sprintf "    double tmp_%s = ((double)msg->%s - %.17g) / %.17g;\n    int64_t raw_%s = (int64_t)(tmp_%s >= 0 ? tmp_%s + 0.5 : tmp_%s - 0.5);" s.Name s.Name s.Offset s.Factor s.Name s.Name s.Name s.Name
            let computeRawFloat =
                sprintf "    float tmp_%s = ((float)msg->%s - (float)%.17g) / (float)%.17g;\n    int64_t raw_%s = (int64_t)llroundf(tmp_%s);" s.Name s.Name s.Offset s.Factor s.Name s.Name
            let computeRaw =
                match config.PhysType.ToLowerInvariant() with
                | "fixed" ->
                    match Utils.tryPowerOfTenScale s.Factor with
                    | Some scale when abs (s.Offset - Math.Round(s.Offset)) < 1e-12 ->
                        sprintf "    int64_t raw_%s = (int64_t)llround(((double)msg->%s - %.0f) * (double)%d);" s.Name s.Name (Math.Round s.Offset) scale
                    | _ -> (match config.PhysMode.ToLowerInvariant() with | "fixed_float" -> computeRawFloat | _ -> computeRawDouble)
                | _ -> (match config.PhysMode.ToLowerInvariant() with | "float" -> computeRawFloat | _ -> computeRawDouble)
            let setBits = sprintf "    %s(data, %d, %d, (uint64_t)raw_%s);" setFn startEff len s.Name
            [ match rangeChecks with | Some r -> yield r | None -> ()
              yield computeRaw
              yield setBits ]
            |> String.concat "\n"

        let private partitionMultiplex (message: Message) =
            let switchOpt = message.Signals |> List.tryFind (fun s -> s.MultiplexerIndicator = Some "M")
            let baseSignals = message.Signals |> List.filter (fun s -> s.MultiplexerIndicator.IsNone)
            let branches =
                message.Signals
                |> List.choose (fun s ->
                    match s.MultiplexerIndicator, s.MultiplexerSwitchValue with
                    | Some ind, Some v when ind = "m" -> Some (v, s)
                    | _ -> None)
                |> List.groupBy fst
                |> List.map (fun (k, xs) -> k, xs |> List.map snd)
            switchOpt, baseSignals, branches

        let generateMessageFiles (message: Message) (outputPath: string) (config: Signal.CANdy.Core.Config.Config) =
            let messageNameLower = message.Name.ToLowerInvariant()
            let messageHPath = Path.Combine(outputPath, "include", sprintf "%s.h" messageNameLower)
            let messageCPath = Path.Combine(outputPath, "src", sprintf "%s.c" messageNameLower)

            let banner = sprintf "/* Generated by Signal CANdy\n   file_prefix=%s, phys_type=%s, phys_mode=%s, dispatch=%s, motorola_start_bit=%s */\n" config.FilePrefix config.PhysType config.PhysMode config.Dispatch config.MotorolaStartBit

            let signalDeclarationsH = message.Signals |> List.map fieldDecl |> String.concat "\n"

            let switchOpt, baseSignals, branches = partitionMultiplex message
            let isMux = match switchOpt, branches with | Some _, _ :: _ -> true | _ -> false
            let validMacro (sigName: string) = sprintf "%s_VALID_%s" (message.Name.ToUpperInvariant()) (sigName.ToUpperInvariant())

            let signalDecodeFor s = genDecodeForSignal s config.RangeCheck config
            let signalDecodeWithValid s = let body = signalDecodeFor s in if isMux then body + (sprintf "\n    msg->valid |= %s;" (validMacro s.Name)) else body

            let signalDecodeC =
                match switchOpt, branches with
                | Some sw, (_ :: _) ->
                    let rawVar = sprintf "raw_%s" sw.Name
                    let swBlock =
                        let body = signalDecodeWithValid sw
                        body + (sprintf "\n    msg->mux_active = (%s_mux_e)((int)%s);" message.Name rawVar)
                    let baseBlock = baseSignals |> List.map signalDecodeWithValid |> String.concat "\n\n"
                    let branchesBlock =
                        branches
                        |> List.map (fun (k, sigs) ->
                            let inner = sigs |> List.map signalDecodeWithValid |> String.concat "\n\n"
                            [ sprintf "    if ((int)%s == %d) {" rawVar k; inner; "    }" ] |> String.concat "\n")
                        |> String.concat "\n"
                    [ if isMux then "    msg->valid = 0u;" else ""
                      swBlock
                      baseBlock
                      branchesBlock ]
                    |> List.filter (fun s -> not (String.IsNullOrWhiteSpace s))
                    |> String.concat "\n\n"
                | _ -> message.Signals |> List.map signalDecodeFor |> String.concat "\n\n"

            let signalEncodeC =
                match switchOpt, branches with
                | Some sw, (_ :: _) ->
                    let len = int sw.Length
                    let startEff = Utils.chooseStartBit sw config
                    let (_, setFn) = Utils.accessorNames sw.ByteOrder
                    let rangeChecks =
                        if config.RangeCheck then
                            match sw.Minimum, sw.Maximum with
                            | Some minV, Some maxV -> Some (sprintf "    if (msg->%s < %.17g || msg->%s > %.17g) { return false; }" sw.Name minV sw.Name maxV)
                            | Some minV, None -> Some (sprintf "    if (msg->%s < %.17g) { return false; }" sw.Name minV)
                            | None, Some maxV -> Some (sprintf "    if (msg->%s > %.17g) { return false; }" sw.Name maxV)
                            | _ -> None
                        else None
                    let computeRawDouble =
                        sprintf "    double tmp_%s = ((double)msg->%s - %.17g) / %.17g;\n    int64_t raw_%s = (int64_t)(tmp_%s >= 0 ? tmp_%s + 0.5 : tmp_%s - 0.5);" sw.Name sw.Name sw.Offset sw.Factor sw.Name sw.Name sw.Name sw.Name
                    let computeRawFloat =
                        sprintf "    float tmp_%s = ((float)msg->%s - (float)%.17g) / (float)%.17g;\n    int64_t raw_%s = (int64_t)llroundf(tmp_%s);" sw.Name sw.Name sw.Offset sw.Factor sw.Name sw.Name
                    let computeRaw =
                        match config.PhysType.ToLowerInvariant() with
                        | "fixed" ->
                            match Utils.tryPowerOfTenScale sw.Factor with
                            | Some scale when abs (sw.Offset - Math.Round(sw.Offset)) < 1e-12 ->
                                sprintf "    int64_t raw_%s = (int64_t)llround(((double)msg->%s - %.0f) * (double)%d);" sw.Name sw.Name (Math.Round sw.Offset) scale
                            | _ -> (match config.PhysMode.ToLowerInvariant() with | "fixed_float" -> computeRawFloat | _ -> computeRawDouble)
                        | _ -> (match config.PhysMode.ToLowerInvariant() with | "float" -> computeRawFloat | _ -> computeRawDouble)
                    let setBits = sprintf "    %s(data, %d, %d, (uint64_t)raw_%s);" setFn startEff len sw.Name
                    let baseBlock = baseSignals |> List.map (fun s -> genEncodeForSignal s config.RangeCheck config) |> String.concat "\n\n"
                    let branchesBlock =
                        branches
                        |> List.map (fun (k, sigs) ->
                            let inner = sigs |> List.map (fun s -> genEncodeForSignal s config.RangeCheck config) |> String.concat "\n\n"
                            [ sprintf "    if ((int)raw_%s == %d) {" sw.Name k; inner; "    }" ] |> String.concat "\n")
                        |> String.concat "\n"
                    [ match rangeChecks with | Some r -> yield r | None -> ()
                      yield computeRaw
                      yield setBits
                      yield baseBlock
                      yield branchesBlock ]
                    |> List.filter (fun s -> not (String.IsNullOrWhiteSpace s))
                    |> String.concat "\n\n"
                | _ -> message.Signals |> List.map (fun s -> genEncodeForSignal s config.RangeCheck config) |> String.concat "\n\n"

            let headerContent =
                let headerLines = System.Collections.Generic.List<string>()
                headerLines.Add(banner)
                headerLines.Add (sprintf "#ifndef %s_H" (message.Name.ToUpperInvariant()))
                headerLines.Add (sprintf "#define %s_H" (message.Name.ToUpperInvariant()))
                headerLines.Add ""
                headerLines.Add "#include <stdint.h>"
                headerLines.Add "#include <stdbool.h>"
                headerLines.Add ""
                headerLines.Add "#ifdef __cplusplus"
                headerLines.Add "extern \"C\" {"
                headerLines.Add "#endif"
                headerLines.Add ""
                // Value-table enums and to_string prototypes
                let vtSignals = message.Signals |> List.choose (fun s -> s.ValueTable |> Option.map (fun vt -> s, vt))
                vtSignals |> List.iter (fun (s, vt) ->
                    let enumName = sprintf "%s_%s_e" message.Name s.Name
                    headerLines.Add (sprintf "typedef enum {")
                    let mutable used = Set.empty
                    vt |> List.iter (fun (v, name) ->
                        let baseLabel = sanitizeEnumIdent name
                        let rec uniqueLabel lbl idx =
                            let candidate = if idx = 0 then lbl else sprintf "%s_%d" lbl idx
                            if used.Contains candidate then uniqueLabel lbl (idx+1) else candidate
                        let label = uniqueLabel baseLabel 0
                        used <- used.Add label
                        headerLines.Add (sprintf "    %s_%s_%s = %d," (message.Name.ToUpperInvariant()) (s.Name.ToUpperInvariant()) label v)
                    )
                    headerLines.Add (sprintf "} %s;" enumName)
                    headerLines.Add ""
                    headerLines.Add (sprintf "const char* %s_%s_to_string(int v);" message.Name s.Name)
                    headerLines.Add ""
                )
                let switchOpt2, _, branches2 = partitionMultiplex message
                let isMux2 = match switchOpt2, branches2 with | Some _, _ :: _ -> true | _ -> false
                if isMux2 then
                    let enumName = sprintf "%s_mux_e" message.Name
                    headerLines.Add (sprintf "typedef enum { ")
                    let enumEntries = branches2 |> List.map (fun (k, _) -> sprintf "    %s_MUX_%d = %d" (message.Name.ToUpperInvariant()) k k) |> String.concat ",\n"
                    headerLines.Add enumEntries
                    headerLines.Add (sprintf "} %s;" enumName)
                    headerLines.Add ""
                    message.Signals |> List.iteri (fun idx s -> headerLines.Add (sprintf "#define %s (1u << %d)" (sprintf "%s_VALID_%s" (message.Name.ToUpperInvariant()) (s.Name.ToUpperInvariant())) idx))
                    headerLines.Add ""
                headerLines.Add "typedef struct {"
                headerLines.Add signalDeclarationsH
                if isMux2 then
                    headerLines.Add "    uint32_t valid;"
                    headerLines.Add (sprintf "    %s_mux_e mux_active;" message.Name)
                headerLines.Add (sprintf "} %s_t;" message.Name)
                headerLines.Add ""
                headerLines.Add (sprintf "bool %s_decode(%s_t* msg, const uint8_t data[], uint8_t dlc);" message.Name message.Name)
                headerLines.Add (sprintf "bool %s_encode(uint8_t data[], uint8_t* out_dlc, const %s_t* msg);" message.Name message.Name)
                headerLines.Add ""
                headerLines.Add "#ifdef __cplusplus"
                headerLines.Add "}"
                headerLines.Add "#endif"
                headerLines.Add ""
                headerLines.Add (sprintf "#endif // %s_H" (message.Name.ToUpperInvariant()))
                String.concat "\n" (List.ofSeq headerLines)

            let sourceContent =
                let src = System.Collections.Generic.List<string>()
                src.Add(banner)
                src.Add (sprintf "#include \"%s.h\"" messageNameLower)
                let utilsHeader = Utils.utilsHeaderName config
                src.Add (sprintf "#include \"%s\"" utilsHeader)
                src.Add "#include <string.h>"
                src.Add "#include <math.h>"
                src.Add ""
                let vtSignals = message.Signals |> List.choose (fun s -> s.ValueTable |> Option.map (fun vt -> s, vt))
                vtSignals |> List.iter (fun (s, vt) ->
                    src.Add (sprintf "const char* %s_%s_to_string(int v) {" message.Name s.Name)
                    src.Add "    switch (v) {"
                    vt |> List.iter (fun (v, name) -> src.Add (sprintf "    case %d: return \"%s\";" v (name.Replace("\"","\\\""))))
                    src.Add "    default: return \"UNKNOWN\";"
                    src.Add "    }"
                    src.Add "}"
                    src.Add ""
                )
                src.Add (sprintf "bool %s_decode(%s_t* msg, const uint8_t data[], uint8_t dlc) {" message.Name message.Name)
                src.Add (sprintf "    if (dlc < %d) { return false; }" (int message.Length))
                src.Add signalDecodeC
                src.Add "    return true;"
                src.Add "}"
                src.Add ""
                src.Add (sprintf "bool %s_encode(uint8_t data[], uint8_t* out_dlc, const %s_t* msg) {" message.Name message.Name)
                src.Add "    memset(data, 0, 8);"
                src.Add (sprintf "    *out_dlc = %d;" (int message.Length))
                src.Add signalEncodeC
                src.Add "    return true;"
                src.Add "}"
                String.concat "\n" (List.ofSeq src)

            File.WriteAllText(messageHPath, headerContent)
            File.WriteAllText(messageCPath, sourceContent)
            messageHPath, messageCPath

    module Registry =
        let generateRegistryFiles (ir: Ir) (outputPath: string) (config: Signal.CANdy.Core.Config.Config) =
            let regHName = sprintf "%sregistry.h" config.FilePrefix
            let regCName = sprintf "%sregistry.c" config.FilePrefix
            let registryHPath = Path.Combine(outputPath, "include", regHName)
            let registryCPath = Path.Combine(outputPath, "src", regCName)

            let guard =
                (config.FilePrefix + "registry_h").ToUpperInvariant()
                |> Seq.map (fun ch -> if Char.IsLetterOrDigit ch then ch else '_')
                |> Seq.toArray
                |> fun arr -> new string(arr)
            let banner = sprintf "/* Generated by Signal CANdy\n   file_prefix=%s, phys_type=%s, phys_mode=%s, dispatch=%s, motorola_start_bit=%s */\n" config.FilePrefix config.PhysType config.PhysMode config.Dispatch config.MotorolaStartBit
            let registryHContent =
                banner + sprintf "#ifndef %s\n#define %s\n\n#include <stdint.h>\n#include <stdbool.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nbool decode_message(uint32_t id, const uint8_t data[], uint8_t dlc, void* msg);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // %s" guard guard guard
            File.WriteAllText(registryHPath, registryHContent)

            let includes = ir.Messages |> List.map (fun m -> sprintf "#include \"%s.h\"" (m.Name.ToLowerInvariant())) |> String.concat "\n"

            let body =
                if config.Dispatch.ToLowerInvariant() = "direct_map" then
                    let cases =
                        ir.Messages
                        |> List.map (fun m -> sprintf "        case %du: return %s_decode((%s_t*)msg, data, dlc);" (int m.Id) m.Name m.Name)
                        |> String.concat "\n"
                    sprintf "bool decode_message(uint32_t id, const uint8_t data[], uint8_t dlc, void* msg) {\n    switch (id) {\n%s\n        default: return false;\n    }\n}" cases
                else
                    let sorted = ir.Messages |> List.sortBy (fun m -> m.Id)
                    let entries = sorted |> List.map (fun m -> sprintf "    { %du, (decode_func_t)%s_decode }" (int m.Id) m.Name) |> String.concat ",\n"
                    let table = sprintf "typedef bool (*decode_func_t)(void* msg, const uint8_t data[], uint8_t dlc);\n\ntypedef struct { uint32_t id; decode_func_t func; } decoder_entry_t;\n\nstatic const decoder_entry_t decoders[] = {\n%s\n};\n" entries
                    let search =
                        "bool decode_message(uint32_t id, const uint8_t data[], uint8_t dlc, void* msg) {\n    int low = 0;\n    int high = (int)(sizeof(decoders) / sizeof(decoder_entry_t)) - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (decoders[mid].id == id) {\n            return decoders[mid].func(msg, data, dlc);\n        }\n        if (decoders[mid].id < id) low = mid + 1; else high = mid - 1;\n    }\n    return false;\n}\n"
                    table + search
            let finalC = banner + "#include <stdint.h>\n#include <stdbool.h>\n#include \"" + (sprintf "%sregistry.h" config.FilePrefix) + "\"\n" + includes + "\n\n" + body
            File.WriteAllText(registryCPath, finalC)
            registryHPath, registryCPath

    // Compatibility shims for legacy includes (utils.h, registry.h)
    let private shimHeader (name: string) (target: string) =
        let guard = (name.Replace('.', '_') + "_SHIM").ToUpperInvariant()
        "#ifndef " + guard + "\n#define " + guard + "\n\n"
        + "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n"
        + "#include \"" + target + "\"\n\n"
        + "#ifdef __cplusplus\n}\n#endif\n\n"
        + "#endif // " + guard

    // Main entry: generate code and return file lists
    let generate (ir: Ir) (outputPath: string) (config: Signal.CANdy.Core.Config.Config) : Result<GeneratedFiles, CodeGenError> =
        try
            // Ensure output directories
            Directory.CreateDirectory (Path.Combine(outputPath, "include")) |> ignore
            Directory.CreateDirectory (Path.Combine(outputPath, "src")) |> ignore

            // Clean stale prefixed common files
            let keepUtilsH = Utils.utilsHeaderName config
            let keepUtilsC = Utils.utilsSourceName config
            let keepRegH = sprintf "%sregistry.h" config.FilePrefix
            let keepRegC = sprintf "%sregistry.c" config.FilePrefix
            let includeDir = Path.Combine(outputPath, "include")
            let srcDir = Path.Combine(outputPath, "src")
            if Directory.Exists includeDir then
                Directory.GetFiles(includeDir, "*utils.h") |> Array.iter (fun f -> if Path.GetFileName(f) <> keepUtilsH then try File.Delete f with _ -> ())
                Directory.GetFiles(includeDir, "*registry.h") |> Array.iter (fun f -> if Path.GetFileName(f) <> keepRegH then try File.Delete f with _ -> ())
            if Directory.Exists srcDir then
                Directory.GetFiles(srcDir, "*utils.c") |> Array.iter (fun f -> if Path.GetFileName(f) <> keepUtilsC then try File.Delete f with _ -> ())
                Directory.GetFiles(srcDir, "*registry.c") |> Array.iter (fun f -> if Path.GetFileName(f) <> keepRegC then try File.Delete f with _ -> ())

            // Generate utils
            let uH = Utils.utilsHeaderName config
            let uC = Utils.utilsSourceName config
            let uHPath = Path.Combine(outputPath, "include", uH)
            let uCPath = Path.Combine(outputPath, "src", uC)
            File.WriteAllText(uHPath, Utils.utilsHContent config)
            File.WriteAllText(uCPath, Utils.utilsCContent config)

            // Emit compatibility shims
            let shimUtilsPath = Path.Combine(outputPath, "include", "utils.h")
            let shimRegPath = Path.Combine(outputPath, "include", "registry.h")
            File.WriteAllText(shimUtilsPath, shimHeader "utils.h" uH)
            File.WriteAllText(shimRegPath, shimHeader "registry.h" keepRegH)

            // Messages
            let msgFiles =
                ir.Messages
                |> List.map (fun m -> Message.generateMessageFiles m outputPath config)
            // Registry
            let regHPath, regCPath = Registry.generateRegistryFiles ir outputPath config

            let sources = msgFiles |> List.map snd |> fun xs -> uCPath :: regCPath :: xs
            let headers = msgFiles |> List.map fst |> fun xs -> uHPath :: regHPath :: shimUtilsPath :: shimRegPath :: xs
            let others : string list = []
            Ok { Sources = sources; Headers = headers; Others = others }
        with ex ->
            Error (CodeGenError.Unknown (sprintf "Codegen exception: %s" ex.Message))
